import System.Random

--getList generates a list of n Ints between 0 and l
getList :: Int -> Int -> StdGen -> [Int]
getList n l g = take n (randomRs (0::Int, l) g)

--maxProfitLeft starts at the left edge of an enumerated list of Ints (i.e. a
--list of Ints where each Int is paired in a tuple with its position in the
--list) and iterates over the list keeping track of the lowest observed value
--(lw), the current maximum diference between any two integers seen up to that
--point in the list (mpf), and the current indexes of the lowest and highest
--numbers yet observed.  It builds a list of triples - one for each position in
--the list - representing these values for each position in the list - in the
--form (low-index, high-index, difference).  (By implication, the rightmost
--member holds the maximum difference as its third member.)  This will be used
--by a later function that performs much the same activity from the right side.
maxProfitLeft :: Int -> Int -> Int -> Int -> [(Int,Int)] -> [(Int,Int,Int)]
maxProfitLeft _ _ _ _ [] = [] 
maxProfitLeft lw mpf mn h ((j,l):ls) = 
  let
    low = min l lw
    minindex = if l < lw then j else mn
    mp = max (l - lw) mpf
    maxindex = if l - lw > mpf then j else h
  in
    (mn,maxindex,mp) : (maxProfitLeft low mp minindex maxindex ls)

thrd :: (a,a,a) -> a
thrd (_,_,e) = e

frst :: (a,a,a) -> a
frst (e,_,_) = e

scnd :: (a,a,a) -> a
scnd (_,e,_) = e

--mp is a helper function for maxProfit, but it is really the driver of the
--algorithm.  Since the problem is to return the pair of purchases that
--maximize profit, this function returns a triple representing
--(maxprofit,(low-left,high-left,profit-left),(low-right,high-right,profit-right))
--such that profit-left + profit-right = maxprofit.  That is, it returns a
--triple showing the maximum profit we can get from this time series of prices
--using exactly two trades paired with details about the trade (when to buy,
--when to sell, how much profit is earned).  It does this by taking in the list
--generated by maxProfitLeft - which is a memo of the best possible result from
--a single trade up to each point in the time series - performing the same
--operation from the right side, and for each point on the right side
--consulting the memo from the left-side list to find the max profit that can
--be gotten from the remainder of the list (i.e. the part of the list we
--haven't gotten to yet), adding that to the max profit we can get from the
--list we've seen so far, and updating the maximum possible value of such a
--pairing as it goes.
mp :: Int -> Int -> Int -> ((Int,Int,Int),(Int,Int,Int),(Int,Int,Int)) -> [(Int,Int)] -> [(Int,Int,Int)] -> (Int,((Int,Int,Int),(Int,Int,Int)))
mp  _ _ fp fl [] _ = (fp,(frst fl, scnd fl))
mp h mpp fp ((x1,x2,x3),(y1,y2,y3),(z1,z2,z3)) ((i,l):ll) rr = 
  let
    hg = max h l --the maximum between the current element in the list and the highest element we've seen so far
    yy2 = if l > h then i else z2 -- if the current element is the highest we've seen so far, update the coordinate for highest value
    maxprf = max (h - l) mpp -- the maximum profit seen so far is the higher of the current-highest seen difference, or the current difference
    yy1 = if h - l > mpp then i else z1 --if the current pairing is the highest we've seen so far, set the low index to the current index
    finalprofit = max fp (maxprf + (thrd $ rr !! i)) --the current best pairing is either the best pairing we've seen so far, or else the current profit plus the best one we can get at this point on the left side
    lhs = if fp > (maxprf + (thrd $ rr !! i)) then (x1,x2,x3) else (rr !! i) --if we just found a new max pairing, record the triple from the left-side array
    rhs = if fp > (maxprf + (thrd $ rr !! i)) then (y1,y2,y3) else (yy1,yy2,maxprf) -- if we just found a new max pairing, record the current triple 
  in
    mp hg maxprf finalprofit (lhs,rhs,(yy1,yy2,0)) ll rr  --recursion

--maxProfit accepts a list representing a time series of stock prices (ll), a
--list of max buy/sells computed by starting at the left of the list (rr) and
--returns a representation of the maximum profit we can make with exactly two
--buy/sell transactions on this time series (with the constraint that we must
--only hold one stock at a time).  See the definition of mp for details of how
--it works.
maxProfit :: [Int] -> [(Int,Int,Int)] -> (Int,((Int,Int,Int),(Int,Int,Int)))
maxProfit ll rr = mp (head . reverse $ ll) 0 0 ((0,0,0),(0,0,0),(0,((length ll)-1),0)) (reverse $ zip [0..] ll) rr

showdollar :: Int -> [Char]
showdollar i = " $" ++ (show i) ++ " "

--printResult converts the result into a human-readable string description of
--what buys and sells to make when to maximize profit, and what that profit
--will be
printResult :: [Int] -> (Int,((Int,Int,Int),(Int,Int,Int))) -> [Char]
printResult stks (total,((x1,x2,x3),(y1,y2,y3))) = "Buy at " ++ (show x1) ++ (showdollar $ stks !! x1) ++ "then sell at " ++ (show x2) ++ (showdollar $ stks !! x2) ++ "to make" ++ (showdollar x3) ++ "\nthen buy at " ++ (show y1) ++ (showdollar $ stks !! y1) ++ " and sell at " ++ (show y2) ++ (showdollar $ stks !! y2) ++ "to make" ++ (showdollar $ y3) ++ "\nfor a total profit of:" ++ (showdollar total) ++ "\n\n"

--main = print $ maxProfitLeft 5 0 [5,9,1,2,7,3,8,3,6,5]
main = do 
  g <- getStdGen
  let stocks = getList 10 10 g
  print $ stocks
  let mp = maxProfit stocks $ maxProfitLeft (head stocks) 0 0 0 (zip [0..] stocks)
  print $ mp
  putStrLn ""
  putStrLn ""
  putStrLn $ printResult stocks mp
